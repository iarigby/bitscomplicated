[{"content":"Despite not being a pure functional language, a lot of praise that python receives are for features that stem from functional paradigms. Many are second nature to python programmers, but over the years I have seen people miss out on some important features. I gathered a few, along with examples, to give a brief demonstration of the convenience they can bring.\nReplace if/else with or With values that might be None, you can use or instead of if/else to provide a default. I had used this for years with Javascript, without knowing it was also possible in Python.\n1 2 3 4 def get_greeting_prefix(user_title: str | None): if user_title: return user_title return \u0026#34;\u0026#34; Above snippet can shortened to this:\n1 2 def get_greeting_prefix(user_title: str | None): return user_title or \u0026#34;\u0026#34; Pattern Matching and Unpacking The overdue arrival of match to python means that so many switch style statements are expressed instead with convoluted if/else blocks. Using match is not even from the functional paradigm, but combining it with unpacking opens up new possibilities for writing more concise code.\nLet\u0026rsquo;s start by looking at a primitive example of unpacking. Some libraries have popularised use of [a, b] = some_fun(), but unpacking in python is much powerful than that.\n1 2 [first, *mid, last] = [1, 2, 3, 4, 5] # first -\u0026gt; 1, mid -\u0026gt; [2, 3, 4], last -\u0026gt; 5 Matching Lists Just look at the boost in readability when we are able to name and extract relevant values effortlessly:\n1 2 3 4 5 def sum(numbers: [int]): if len(numbers) == 0: return 0 else: return numbers[0] + sum(numbers[1:]) 1 2 3 4 5 6 def sum(numbers: [int]): match numbers: case []: return 0 case [first, *rest]: return first + sum(rest) Matching Dictionaries Smooth, right? We can go even further with dictionaries. This example is not necessarily better than its if/else counterpart, but I will use it for the purpose of demonstrating the functionality.\n1 2 3 4 5 6 7 8 9 10 sample_country = {\u0026#34;economic_zone\u0026#34;: \u0026#34;EEA\u0026#34;, \u0026#34;country_code\u0026#34;: \u0026#34;AT\u0026#34;} def determine_tourist_visa_requirement(country: dict[str, str]): match country: case {\u0026#34;economic_zone\u0026#34;: \u0026#34;EEA\u0026#34;}: return \u0026#34;no_visa\u0026#34; case {\u0026#34;country_code\u0026#34;: code} if code in tourist_visa_free_countries: return \u0026#34;non_tourist_visa_only\u0026#34; case default: return \u0026#34;visa_required\u0026#34;\tMatching Dataclasses Let’s write a function that does a primitive calculation of an estimated number of days for shipment\n1 2 3 4 5 @dataclass class Address: street: str zip_code: str country_code: str 1 2 3 4 5 6 7 8 def calculate_shipping_estimate(address: Address) -\u0026gt; int: match address: case Address(zip_code=zc) if close_to_warehouse(zc): return 1 case Address(country_code=cc) if cc in express_shipping_countries: return 2 case default: return provider_estimate(city.coordinates) Comprehensions List comprehensions get their deserved spotlight, but I’ve seen cases where dictionary comprehension would’ve cut multiple lines. You can look at examples on this page on python.org\n","date":"2024-10-20T00:00:00Z","image":"https://bitscomplicated.com/p/03-functional-python/cover_hu14348444796564806951.jpg","permalink":"https://bitscomplicated.com/p/03-functional-python/","title":"Functional Programming Tips in Python"},{"content":"How do we navigate the myriad of concepts that make the code actually work? Growth journey of a software engineer is complex, and the sheer amount of directions you need to develop in can seem disorienting.\nI frequently get asked for resources that helped me get so comfortable around linux/servers, terminal, the SDLC, deployments. Faced with this question, I always find myself struggling to point to a guide or a course of some sort, as I have not technically used anything major. What I slowly realised though, is that while I cannot share the process, it could be far more valuable to recommend a set of goals which would guide a person to embark on their own path to accomplishing it.\nWe learn by doing, but how do we find out what we should do? The goals themselves are extremely short and concise, and what I love about them is that you can keep iterate over simple steps multiple times and keep expanding your knowledge around them.\nMore important are the constraints around them - constraints which I consider essential for productive learning. The convenience of modern one-click deployments like Vercel and Netlify is invaluable, and they do help the learning process by abstracting away complex processes, but at some point of your journey as the programmer, you need to take a step towards facing these complexities.\nYour Goals rent a vps from a cloud provider ssh into it install docker, or the runtime that you need copy or download the artifact run the program open the ports and access the app over public ip (of the vps) Your Process Do Use search engines, forums and documentation for solving specific problems. Assess and dial the difficulty up/down for each step. Do not hold back from easing up the requirements and taking shortcuts, but return and improve on them later Don\u0026rsquo;t use GPTs - the exercise is for developing your abilities for information synthesis and knowledge navigation. We need to consciously make room for advancing these skills, and that means occasionally refraining from taking the easy path in order to practice Find and follow a comprehensive guide which includes all or multiple steps. We need to engage in active learning here and connect the dots ourselves. These constraints mean the process will be slower than following spelled out instructions, but slowing down and challenging ourselves is the point. Letting our brains construct the connections between processes and ideas results in the strong foundation we need to keep reaching higher.\nNext Steps I am working on a few suggestions to iteratively go deeper into the process. Let me know if you complete these and I\u0026rsquo;ll share the new ones!\nCover Photo by Christophe Ferron on Unsplash\n","date":"2024-09-05T00:00:00Z","image":"https://bitscomplicated.com/p/02-programmer-exercise/cover_hu4086670952592391110.jpg","permalink":"https://bitscomplicated.com/p/02-programmer-exercise/","title":"Not sure how to break through the wall of being a junior? This exercise will help"}]